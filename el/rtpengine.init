#!/bin/bash
#
# rtpengine    Startup script for NGCP rtpengine
#
# chkconfig: 345 84 16
# description: NGCP rtpengine
#
# processname: rtpengine
# config: /etc/sysconfig/rtpengine
# pidfile: /var/run/rtpengine.pid
#
### BEGIN INIT INFO
# Provides: rtpengine
# Required-Start: $local_fs $network
# Short-Description: NGCP rtpengine
# Description: NGCP rtpengine
### END INIT INFO

# Source function library.
. /etc/rc.d/init.d/functions

if [ ! -f /etc/sysconfig/rtpengine ] ; then
  echo "Error: /etc/sysconfig/rtpengine not present"
  exit -1
fi

. /etc/sysconfig/rtpengine

rtpengine=/usr/sbin/rtpengine
prog=rtpengine
pidfile="${PIDFILE-/var/run/rtpengine.pid}"
lockfile="${LOCKFILE-/var/lock/subsys/rtpengine}"
cachefile=/var/lib/ngcp-rtpengine/rtpengine.cfg

OPTS="--pidfile ${pidfile}"
MODULE=0

build_opts() {
  shopt -s nocasematch
  RPMS=$(rpm -qa | grep rtpengine-kernel)

  if [[ "${KERNEL}" == "yes" && -n "${TABLE}" && -n "${RPMS}" ]] ; then
    MODULE=1
    OPTS+=" --table=${TABLE}"
  else
    MODULE=0
    OPTS+=" --table=-1"
  fi

  [ "${FALLBACK}" != "yes" ] && OPTS+=" --no-fallback"

  shopt -u nocasematch

  if [ -n "${RTP_IP}" ] ; then
    for IP in "${RTP_IP[@]}" ; do
      OPTS+=" --interface=${IP}"
    done
  fi

  [ -n "${LISTEN_TCP}" ]     && OPTS+=" --listen-tcp=${LISTEN_TCP}"
  [ -n "${LISTEN_UDP}" ]     && OPTS+=" --listen-udp=${LISTEN_UDP}"
  [ -n "${LISTEN_NG}" ]      && OPTS+=" --listen-ng=${LISTEN_NG}"
  [ -n "${LISTEN_CLI}" ]     && OPTS+=" --listen-cli=${LISTEN_CLI}"
  [ -n "${TOS}" ]            && OPTS+=" --tos=${TOS}"
  [ -n "${TIMEOUT}" ]        && OPTS+=" --timeout=${TIMEOUT}"
  [ -n "${SILENT_TIMEOUT}" ] && OPTS+=" --silent-timeout=${SILENT_TIMEOUT}"
  [ -n "${PORT_MIN}" ]       && OPTS+=" --port-min=${PORT_MIN}"
  [ -n "${PORT_MAX}" ]       && OPTS+=" --port-max=${PORT_MAX}"
  [[ -n "${REDIS}" && -n "${REDIS_DB}" ]] && OPTS+=" --redis=${REDIS}/${REDIS_DB}"
  [ -n "${B2B_URL}" ]        && OPTS+=" --b2b-url=${B2B_URL}"
  [ -n "${LOG_LEVEL}" ]      && OPTS+=" --log-level=${LOG_LEVEL}"
  [ -n "${LOG_FACILITY}" ]   && OPTS+=" --log-facility=${LOG_FACILITY}"
  [ -n "${NUM_THREADS}" ]    && OPTS+=" --num-threads=${NUM_THREADS}"
  [ -n "${DELETE_DELAY}" ]   && OPTS+=" --delete-delay=${DELETE_DELAY}"
  [ -n "${GRAPHITE}" ]       && OPTS+=" --graphite=${GRAPHITE}"
  [ -n "${GRAPHITE_INTERVAL}" ]  && OPTS+=" --graphite-interval=${GRAPHITE_INTERVAL}"
  [ -n "${GRAPHITE_PREFIX}" ]    && OPTS+=" --graphite-prefix=${GRAPHITE_PREFIX}"
  [ -n "${LOG_FACILITY_CDR}" ]   && OPTS+=" --log-facility-cdr=${LOG_FACILITY_CDR}"
  [ -n "${LOG_FACILITY_RTCP}" ]  && OPTS+=" --log-facility-rtcp=${LOG_FACILITY_RTCP}"
  [ -n "${MAX_SESSIONS}" ]       && OPTS+=" --max-sessions=${MAX_SESSIONS}"
}

start() {
  build_opts

  if [ "${MODULE}" == "1" ] ; then
    echo "Loading module for in-kernel packet forwarding"
    rmmod xt_RTPENGINE 2> /dev/null

    if [ -n "${RE_USER}" ] ; then
      if [ -n "${RE_GROUP}" ] ; then
        proc_gid=$(grep "^${RE_GROUP}:" /etc/group | cut -f3 -d:)
      else
        proc_gid=$(id "${RE_USER}" -g)
      fi
      modprobe xt_RTPENGINE proc_uid=$(id "${RE_USER}" -u) proc_gid=${proc_gid}
    else
      modprobe xt_RTPENGINE
    fi

    if firewall-cmd --state 2>/dev/null ; then
      # Using firewalld
      # Need to check if the INPUT_prefilter chain is present (permanently)
      if ! firewall-cmd --permanent --direct --query-chain ipv4 filter INPUT_prefilter > /dev/null ; then
        firewall-cmd --permanent --direct --add-chain ipv4 filter INPUT_prefilter
        firewall-cmd --permanent --direct --passthrough ipv4 -t filter -I INPUT -j INPUT_prefilter
        firewall-cmd --reload
      fi

      firewall-cmd --direct --add-chain ipv4 filter rtpengine
      firewall-cmd --direct --add-rule ipv4 filter INPUT_prefilter 0 -j rtpengine
      firewall-cmd --direct --add-rule ipv4 filter rtpengine 0 -p udp -j RTPENGINE --id "${TABLE}"
      firewall-cmd --direct --add-rule ipv6 filter rtpengine 0 -p udp -j RTPENGINE --id "${TABLE}"
      firewall-cmd --reload
    else

      iptables -N rtpengine
      # We insert the rtpengine rule at the top of the input chain
      iptables -t filter -I INPUT -j rtpengine
      iptables -I rtpengine -p udp -j RTPENGINE --id "${TABLE}"
      ip6tables -I rtpengine -p udp -j RTPENGINE --id "${TABLE}"
    fi

    echo "CUR_TABLE=${TABLE}" > "${cachefile}"
  fi

  echo -n $"Starting ${prog}: "
  if [ -n "${RE_USER}" ] ; then
    # shellcheck disable=SC2086
    daemon --user "${RE_USER}" --pidfile="${pidfile}" "${rtpengine}" ${OPTS}
    local RETVAL=$?
  else
    # shellcheck disable=SC2086
    daemon --pidfile="${pidfile}" "${rtpengine}" ${OPTS}
    local RETVAL=$?
  fi

  echo
  [ "${RETVAL}" = "0" ] && touch "${lockfile}"
  return "${RETVAL}"
}

stop() {
  echo -n $"Stopping ${prog}: "

  killproc -p "${pidfile}" "${rtpengine}"
  local RETVAL=$?
  echo

  if [ -f "${cachefile}" ] ; then
    . "${cachefile}"

    echo "Unloading module for in-kernel packet forwarding"
    # TODO: should below be ${CUR_TABLE} ???
    echo "del ${TABLE}" > /proc/rtpengine/control

    if firewall-cmd --state 2>/dev/null ; then
      firewall-cmd --direct --remove-rules ipv4 filter rtpengine
      firewall-cmd --direct --remove-rules ipv6 filter rtpengine
      firewall-cmd --direct --remove-rule ipv4 filter INPUT_prefilter 0 -j rtpengine
      firewall-cmd --direct --remove-chain ipv4 filter rtpengine
      firewall-cmd --reload
    else
      iptables -D rtpengine -p udp -j RTPENGINE --id "${CUR_TABLE}"
      ip6tables -D rtpengine -p udp -j RTPENGINE --id "${CUR_TABLE}"
      iptables -t filter -D INPUT -j rtpengine
      iptables -X rtpengine
    fi

    rmmod xt_RTPENGINE
    rm -f "${cachefile}"
  fi

  [ "${RETVAL}" = "0" ] && rm -f "${lockfile}" "${pidfile}"
  return "${RETVAL}"
}

# See how we were called.
case "$1" in
  start)
    start
    RETVAL=$?
    ;;
  stop)
    stop
    RETVAL=$?
    ;;
  status)
    status -p "${pidfile}" "${rtpengine}"
    RETVAL=$?
    ;;
  restart)
    stop
    start
    RETVAL=$?
    ;;
  condrestart|try-restart)
    if status -p "${pidfile}" "${rtpengine}" >&/dev/null; then
      stop
      start
      RETVAL=$?
    else
      RETVAL=1
    fi
    ;;
  *)
    echo $"Usage: ${prog} {start|stop|restart|condrestart|try-restart|status}"
    RETVAL=2
    ;;
esac

exit ${RETVAL:-0}
